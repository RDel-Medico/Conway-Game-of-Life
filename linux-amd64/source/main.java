/* autogenerated by Processing revision 1286 on 2023-03-31 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class main extends PApplet {

//Color used for the app
final Color black = new Color (0);
final Color lightBlue = new Color(162, 240, 235);
final Color green = new Color(62, 170, 5);

Game game; // The instance of the game

/*
 app.app[0] = Home
 app.app[1] = Simulation
 app.app[2] = Option
 app.app[3] = Credit
 */
Application app;

//The current frame of the simulation
int currentFrame = 0;

/*
keyPreesseds[0] = true if Z is pressed
keyPreesseds[1] = true if S is pressed
keyPreesseds[2] = true if Q is pressed
keyPreesseds[3] = true if D is pressed
*/
boolean keyPresseds[] = new boolean[]{false, false, false, false};

 public void setup() {
  /* size commented out by preprocessor */;

  //Creation of the app and all it's menu
  app = new Application(initMenuHome());
  app.addMenu(initMenuSimulation());
  app.addMenu(initMenuSettings());
  app.addMenu(initMenuCredit());

  //Creation of the game
  game = new Game(app.app[2].cursors[0].value, app.app[2].cursors[1].value, new Color(app.app[2].cursors[1].value, app.app[2].cursors[3].value, app.app[2].cursors[4].value));

  //Selection of the font
  PFont myFont = createFont(PFont.list()[158], 32);
  textFont(myFont);

  //Select the frameRate
  frameRate(60);
}


 public void draw() {
  if (app.currentMenu != app.app[1]) { // On any menu except the simulation one, we display the classic background
    backgroundPage();
  } else { // If we are on the simulation menu
    background(255);
    game.display(); //Display the game (grid + cell alive)

    if (game.running) { // If the auto simulation is running
      game.run(currentFrame);

      //update the currenteFrame
      currentFrame++;
      if (currentFrame == 60) {
        currentFrame = 0;
      }
    }
  }

  app.display(); // We display the app (the currentMenu)

  if (app.currentMenu == app.app[2]) { // If we are in the settings we display the color picked visualizer
    stroke(0);
    strokeWeight(2);
    fill(app.currentMenu.cursors[2].value, app.currentMenu.cursors[3].value, app.currentMenu.cursors[4].value);
    rect(30, 480, 160, 250);
  }

  if (app.currentMenu == app.app[1]) { // If we are in the simulation we manage the movement
    manageMovement();
  }
}

 public void manageMovement() { // Manage all the movement on the grid
  
  if (keyPresseds[0]) { // Going to the top
    if (game.offsetY < 0) {
      game.offsetY+=10;
      game.updateCellPosition(); 
    }
  }
  if (keyPresseds[1]) { // Going to the bottom
    if (height-game.offsetY < game.nbCellHauteur * game.allCell[0].longeur) {
      game.offsetY-=10;
      game.updateCellPosition();
    }
  }
  if (keyPresseds[2]) { // Going to the left
    if (game.offsetX < 0) {
      game.offsetX+=10;
      game.updateCellPosition();
    }
  }
  if (keyPresseds[3]) { // Going to the right
    if (width-game.offsetX < game.nbCellLargeur * game.allCell[0].largeur) {
      game.offsetX-=10;
      game.updateCellPosition();
    }
  }
}
 public void mouseWheel(MouseEvent event) {
  if (app.currentMenu == app.app[1]) { //scrolling while in the simulation menu
    if (event.getCount() == -1) { // scroll out
      game.decrementZomm();
    } else { //  scroll in
      game.incrementZomm();
    }
    game.updateZoom();
  }
}

 public void keyPressed() {
  if (app.currentMenu == app.app[1]) { // If on the simulation menu, we update the keyPresseds
    if (keyCode == 'Z') {
      keyPresseds[0] = true;
    }
    if (keyCode == 'S') {
      keyPresseds[1] = true;
    }
    if (keyCode == 'Q') {
      keyPresseds[2] = true;
    }
    if (keyCode == 'D') {
      keyPresseds[3] = true;
    }
  }
}

 public void keyReleased() {
  if (app.currentMenu == app.app[1]) { // If on the simulation menu, we update the keyPresseds
    if (keyCode == 'Z') {
      keyPresseds[0] = false;
    }
    if (keyCode == 'S') {
      keyPresseds[1] = false;
    }
    if (keyCode == 'Q') {
      keyPresseds[2] = false;
    }
    if (keyCode == 'D') {
      keyPresseds[3] = false;
    }
  }
}

 public void mousePressed() {
  //Manage a click on the app
  app.click();

  if (game.running == false && app.currentMenu == app.app[1]) { // If the click append while the game is not running and in the simulation menu

    if (app.release() == -1 && !(app.app[1].cursors[0].selectorClicked())) { // If the click is not on a button or a cursor while the game is not running
      game.click(); // We do a click on the game (change the state of the cell we clicked on)
      game.display();
    } else if (app.release() == 1) { // click on button Next step while the game is not running
      game.nextStep(); // we go to next step
    }
  }
}

 public void mouseDragged() {
  if (game.running == false && app.currentMenu == app.app[1]) { // If the game is not running and in the simulation menu
    app.dragged(); // Let the app manage cursors dragging
    game.setSpeed(app.app[1].cursors[0].value); // We change the speed of the game
    currentFrame = 0;
  } else if (app.currentMenu != app.app[1]) {
    app.dragged();
  }
}

 public void mouseReleased() {

  /*
  We manage all the button
   */

  if (app.currentMenu == app.app[0]) { // Manage buttons of Home

    if (app.release() == 0) { // Button Simulation
      app.changeMenu(1); //Menu active become Simulation
    }

    if (app.release() == 1) { // Button settings
      app.changeMenu(2); // Menu active become settings
    }

    if (app.release() == 2) { // Button credit
      app.changeMenu(3); // Menu active become credit
    }
    
    if (app.release() == 3) { // Button credit
      exit(); // Menu active become credit
    }
  } else if (app.currentMenu == app.app[2]) { // Manage buttons of Settings

    if (app.release() == 0) { // Button back
      app.changeMenu(0); // Menu active become home
      game = new Game(app.app[2].cursors[0].value, app.app[2].cursors[1].value, new Color(app.app[2].cursors[2].value, app.app[2].cursors[3].value, app.app[2].cursors[4].value)); // We create a new game with the new value
    }
  } else if (app.currentMenu == app.app[3]) { // Manage buttons of Credit

    if (app.release() == 0) { // Button back
      app.changeMenu(0); // Menu active become home
    }
  } else if (app.currentMenu == app.app[1]) { // Manage buttons of simulation

    if (app.release() == 0) { // Button back
      app.changeMenu(0); // Menu active become home
    } else if (app.release() == 2 && game.running == false) { // Button Run
      //Set running true and change text of run button
      game.running = true;
      app.app[1].buttons[2].text = "Stop";
    } else if (app.release() == 2 && game.running == true) { // button Stop
      //Set running false and change text of stop button
      game.running = false;
      app.app[1].buttons[2].text = "Run";
    }
  }
}

/*
Generic background for the app
 */
 public void backgroundPage() {
  background(255); //white backgroud
  stroke(70);
  strokeWeight(2);

  //black line
  for (int i = 0; i < 20; i++) {
    line(i * (width/20), 0, i * (width/20), height);
    line(0, i * (width/20), width, i * (width/20));
  }
}

/*
Function to create the menu home
 */
 public Menu initMenuHome() {
  Button b;
  Text t;
  Menu home = new Menu();

  //Title
  t = new Text("Game of Life", width/2, 200, 100, black);
  home.addText(t);

  //Button simulation
  b = new Button (width/2, 350, 400, 100, lightBlue, "Simulation");
  home.addButton(b);

  //Button settings
  b = new Button (width/2, 500, 400, 100, lightBlue, "Settings");
  home.addButton(b);

  //Buton credit
  b = new Button (width/2, 650, 400, 100, lightBlue, "Credit");
  home.addButton(b);
  
  //Buton Quit
  b = new Button (width/2, 800, 400, 100, lightBlue, "Quit");
  home.addButton(b);

  return home;
}

/*
Function to create the menu simulation
 */
 public Menu initMenuSimulation() {
  Button b;
  Text t;
  Cursor c;
  Menu simulation = new Menu();

  //Button back
  b = new Button (105, height-50, 150, 50, lightBlue, "Back");
  simulation.addButton(b);

  //Button next Step
  b = new Button (width/2, height-50, 250, 50, lightBlue, "Next step");
  simulation.addButton(b);

  //Button run
  b = new Button (width/2 + 350, height-50, 150, 50, lightBlue, "Run");
  simulation.addButton(b);

  //Cursors to select simulation speed
  c = new Cursor(width/2, 50, 400, 1, 30);
  simulation.addCursor(c);

  //Text for the cursors
  t = new Text("Step/s", width/2 - 285, 55, 30, black);
  simulation.addText(t);
  
  //Indication
  t = new Text("You can move around with Z, Q, S, D", width/2, 100, 30, green);
  simulation.addText(t);
  
  t = new Text("You can scroll out or in to zoom", width/2, 130, 30, green);
  simulation.addText(t);

  return simulation;
}

/*
Function to create the menu settings
 */
 public Menu initMenuSettings() {
  Button b;
  Text t;
  Cursor c;
  Menu option = new Menu();

  //Title of the menu
  t = new Text("Settings", width/2, 100, 100, black);
  option.addText(t);

  //------------------------------Map settings------------------------------------
  //Little title
  t = new Text("Map settings", width/2, 200, 50, black);
  option.addText(t);

  //Text + cursor for width
  t = new Text("Width of the map", width/2 - 300, 265, 30, black);
  option.addText(t);

  c = new Cursor(width/2 + 50, 260, 400, 10, 200);
  option.addCursor(c);

  //Text + cursor for height
  t = new Text("Height of the map", width/2 - 300, 360, 30, black);
  option.addText(t);

  c = new Cursor(width/2 + 50, 355, 400, 10, 200);
  option.addCursor(c);
  //-----------------------------------------------------------------------------

  //------------------------------Color settings---------------------------------
  //Little title
  t = new Text("Color of Cell", width/2, 430, 50, black);
  option.addText(t);

  //Text + cursor for red
  c = new Cursor(width/2 + 50, 500, 400, 0, 255);
  option.addCursor(c);

  t = new Text("Red", width/2 - 200, 505, 30, black);
  option.addText(t);

  //Text + cursor for green
  c = new Cursor(width/2 + 50, 595, 400, 0, 255);
  option.addCursor(c);

  t = new Text("Green", width/2 - 200, 600, 30, black);
  option.addText(t);

  //Text + cursor for blue
  c = new Cursor(width/2 + 50, 710, 400, 0, 255);
  option.addCursor(c);

  t = new Text("Blue", width/2 - 200, 715, 30, black);
  option.addText(t);
  //-----------------------------------------------------------------------------

  //Button back
  b = new Button (width/2, 800, 400, 100, lightBlue, "Back");
  option.addButton(b);

  return option;
}

/*
Function to create the menu Credit
 */
 public Menu initMenuCredit() {
  Button b;
  Text t;
  Menu credit = new Menu();

  //Button back
  b = new Button (width/2, 650, 400, 100, lightBlue, "Back");
  credit.addButton(b);

  //Text created by
  t = new Text("Created By", width/2, 200, 100, black);
  credit.addText(t);

  t = new Text("Rémi Del Medico", width/2, 400, 70, black);
  credit.addText(t);

  return credit;
}
/*
This class manage an app (All the menu)
 */
class Application {
  Menu[] app; // All the men of the app
  Menu currentMenu; // The current menu we are on

  Application(Menu m) {
    this.app = new Menu[0];
    this.addMenu(m);
    this.currentMenu = m;
  }

  /*
  Change the current menu to the menu m
   */
   public void changeMenu(int m) {
    this.currentMenu = this.app[m];
  }

  /*
  Add a menu to the list of menu of the app
   */
   public void addMenu(Menu m) {
    this.app = (Menu[]) append(app, m);
  }

  /*
  Display the current menu
   */
   public void display() {
    currentMenu.display();
  }

  /*
  Manage a click on the current menu
   */
   public void click() {
    this.currentMenu.click();
  }

  /*
  Manage a mouse drag on the current menu
   */
   public void dragged() {
    this.currentMenu.dragged();
  }
  /*
  Manage a click release on the currentMenu
   Return the index of the button clicked on the current menu or -1 if no button clicked
   */
   public int release() {
    return this.currentMenu.release();
  }
}

/*
This class represent a Cell of the game
 */
class Cell {
  //Display variable
  float posX;
  float posY;
  float largeur;
  float longeur;

  int index; // index of the cell on the current grid

  boolean alive; // is the cell alive

  Color col; // The color of the cell when she is alive

  Cell (float x, float y, float largeur, float longeur, Color col, int index) {
    this.posX = x;
    this.posY = y;
    this.largeur = largeur;
    this.longeur = longeur;
    this.alive = false;
    this.col = col;
    this.index = index;
  }

  /*
  Display the cell (colored if alive)
   */
   public void display() {
    noStroke();
    if (this.alive) {
      fill(col.red, col.green, col.blue);
    } else {
      fill(255);
    }
    rect(posX+1, posY+1, largeur-2, longeur-2);
  }
}

/*
This class represent a color (Red,  Green, Blue)
 */
class Color {
  int red;
  int green;
  int blue;

  //Constructor for normal color
  Color (int r, int g, int b) {
    this.red = r;
    this.green = g;
    this.blue = b;
  }

  //Constructor for grey variante
  Color (int b) {
    this.red = b;
    this.green = b;
    this.blue = b;
  }
}


/*
This class represent a button
 */
class Button {

  String text; // Text on the button
  int posX;
  int posY;
  int largeur;
  int hauteur;

  Color col; // Color of the button

  boolean clicked; // Is the button currently clicked


  Button(int x, int y, int largeur, int hauteur, Color col, String text) {
    this.posX = x - largeur / 2;
    this.posY = y - hauteur / 2;
    this.largeur = largeur;
    this.hauteur = hauteur;
    this.col = col;
    this.clicked = false;
    this.text = text;
  }

  // Return true if the mouse is hovering the button
   public boolean mouseHover () {
    return mouseX >= this.posX && mouseX <= this.posX + this.largeur && mouseY >= this.posY && mouseY <= this.posY + this.hauteur;
  }

  // Set clicked at true if the button is hovered
   public void clicked() {
    if (this.mouseHover()) {
      this.clicked = true;
    }
  }

  //Set clicked at false if the button is hovered
   public boolean released() {
    this.clicked = false;
    return this.mouseHover();
  }

  //Display the button Normal color if not overed, darker color if hovered, and change the border based on if the button is clicked
   public void display() {

    //Border depend on if the button is clicked
    if (this.clicked) {
      stroke(100);
      strokeWeight(5);
    } else {
      stroke(0);
      strokeWeight(5);
    }

    //Filling of the button depend on if the button is hovered
    if (this.mouseHover()) {
      fill(this.col.red - 50, this.col.green - 50, this.col.blue - 50);
    } else {
      fill(this.col.red, this.col.green, this.col.blue);
    }

    //Button
    rect(posX, posY, largeur, hauteur);

    //Text on the button
    textSize(50);
    textAlign(CENTER);
    fill(0);
    text(this.text, this.posX + this.largeur / 2, this.posY + this.hauteur / 2 + 15);
  }
}

/*
This represent a movable cursor to select a data
 */
class Cursor {
  //Display parameters
  int posX;
  int posY;
  int largeur;

  float valuePourcent; // The pourcent of the value we want (cursors full left = 0 and cursor full right = 1)
  int valueMin; // The minimal value we can go on the cursor
  int valueMax; // The maximal value we can go on the cursor
  int value; // The current value Selected

  Cursor (int posX, int posY, int largeur, int min, int max) {
    this.posX = posX;
    this.posY = posY;
    this.valuePourcent = 0;
    this.largeur = largeur;
    this.valueMin = min;
    this.valueMax = max;
    this.value = valueMin;
  }

  //Update the currentValue based on the min, max and the currentValue in pourcent
   public void updateValue() {
    this.value = this.valueMin + (int)(( this.valueMax - this.valueMin ) * valuePourcent);
  }

  //Display the bar of the cursors
   public void displayBar() {
    fill(150);
    stroke(100);
    strokeWeight(2);
    rect(posX - largeur / 2, posY - 5, largeur, 10);
  }

  //Display the selector of the cursor (the moving circle)
   public void displaySelector() {
    fill(lightBlue.red, lightBlue.green, lightBlue.blue);
    stroke(0);
    strokeWeight(2);
    circle((posX - largeur / 2) + largeur * valuePourcent, posY, 30);
  }

  //Display the current value as a text in a rectangle
   public void displayValue() {
    fill(lightBlue.red, lightBlue.green, lightBlue.blue);
    strokeWeight(2);
    stroke(0);
    rect(posX - largeur / 2 + largeur + 20, posY - 20, 75, 40);
    fill(0);
    textSize(30);
    text(this.value, posX - largeur / 2 + largeur + 57, posY + 10);
  }

  // return true if the mouse is hovering the selector and false otherwise
   public boolean selectorClicked() {
    int x = (int)((posX - largeur / 2) + largeur * valuePourcent);
    //Distance to from mouse to center of selector inferior to radius of the selector
    return sqrt(pow(max(mouseX, x) - min(mouseX, x), 2) + pow(max(mouseY, this.posY) - min(mouseY, this.posY), 2)) < 30;
  }

  //Display the whole cursor
   public void display() {
    displayBar();
    displaySelector();
    displayValue();
  }
}

/*
This class reprensent a text
 */
class Text {
  int fontWeight;
  String text;
  int posX;
  int posY;
  Color col;

  Text (String text, int x, int y, int size, Color col) {
    this.posX = x;
    this.posY = y;
    this.col = col;
    this.text = text;
    this.fontWeight = size;
  }
  /*
  Display the text
   */
   public void display() {
    textSize(this.fontWeight);
    fill(this.col.red, this.col.green, this.col.blue);
    textAlign(CENTER);
    text(this.text, posX, posY);
  }
}
/*
This class represente an instance of the game of life
 */
class Game {
  Cell [] allCell; // Represent all the cell of the game
  Cell [] cellAlive; // Represent all the celle alive of the game

  //dimension of the game
  int nbCellLargeur;
  int nbCellHauteur;


  int zoom; //The value of the zoom on the game

  // The offset to move the camera around
  int offsetX;
  int offsetY;

  int lineSize; // Size of the line between each cell

  //Parameters related to the auto simulation
  int speed; // speed is equals to the number of frame it take to do a step (max 59 is the slowest, min 1 is the fastest)
  int previousFrame;
  boolean running; // is the game running

  Game (int nbCellLargeur, int nbCellHauteur, Color col) {
    //initialisation of dimension of the game
    this.nbCellLargeur = nbCellLargeur;
    this.nbCellHauteur = nbCellHauteur;
    this.zoom = 0;
    this.offsetX = 0;
    this.offsetY = 0;
    this.lineSize = 10;

    //initialisation of parameters related to the auto simulation
    this.speed = 59;
    this.previousFrame = 0;
    this.running = false;

    //No cell at first
    allCell = new Cell[0];
    cellAlive = new Cell[0];

    //initialisation of all cell (dead by default)
    for (int i = 0; i < nbCellHauteur; i++) {
      for (int j = 0; j < nbCellLargeur; j++) {
        allCell = (Cell[]) append(allCell, new Cell(j * 90 + offsetX, i*90 + offsetY, 90, 90, col, i*nbCellLargeur+j));
      }
    }

    // Center the camera
    centerTheGame();
    updateCellPosition();
  }

  //Center the camera based on the size of the grid
   public void centerTheGame() {
    this.offsetX = -(int)((this.nbCellLargeur * this.allCell[0].largeur) / 2 - width/2);
    this.offsetY = -(int)((this.nbCellHauteur * this.allCell[0].longeur) / 2 - height/2);
  }

  /*
  Function that manage the auto simulation (function need to be called each frame)
   */
   public void run (int currentFrame) {
    if (currentFrame < previousFrame) { // if the current frame looped (since it is modulo 60)
      if (currentFrame + 60 == previousFrame + speed) { // We add 60
        previousFrame = currentFrame;
        this.nextStep();
      }
    } else if (currentFrame == previousFrame + speed) { // Otherwise we can directly compare
      previousFrame = currentFrame;
      this.nextStep();
    }
  }

  /*
  Increment the zoom
   */
   public void incrementZomm () {
    if (this.zoom < 80) { // If the zoom is not already at it's maximum
      if (this.offsetY <= -nbCellHauteur && this.offsetX <= -nbCellLargeur && (height-this.offsetY < this.nbCellHauteur * (this.allCell[0].longeur-2)) && (width-game.offsetX < game.nbCellLargeur * (game.allCell[0].largeur-2))) { // If the zoom is not gonna show out of the grid
        this.zoom+=2;
        
        //We keep the center at the center after the zoom
        this.offsetX += this.nbCellLargeur;
        this.offsetY += this.nbCellHauteur;
      }
    }
  }

  /*
  Decrement the zoom
   */
   public void decrementZomm () {
    if (this.zoom > 0) {
      this.zoom-=2;
      
      //We keep the center at the center after the zoom
      this.offsetX -= this.nbCellLargeur;
      this.offsetY -= this.nbCellHauteur;
    }
  }

  /*
Update the line size between the cell based on how much the game is zoomed and update all the cell with the current zoom
   */
   public void updateZoom() {
    if (this.zoom > 60) {
      this.lineSize = 2;
    } else if (this.zoom > 30) {
      this.lineSize = 5;
    } else {
      this.lineSize = 10;
    }
    updateCellPosition();
  }

  /*
Update all the cell position, when there is a new offset or a new zoom
   */
   public void updateCellPosition() {
    for (int i = 0; i < nbCellHauteur; i++) {
      for (int j = 0; j < nbCellLargeur; j++) {
        allCell[i*nbCellLargeur+j].posX = j * (90-zoom) + offsetX;
        allCell[i*nbCellLargeur+j].posY = i * (90-zoom) + offsetY;
        allCell[i*nbCellLargeur+j].largeur = 90 - zoom;
        allCell[i*nbCellLargeur+j].longeur = 90 - zoom;
      }
    }
  }

  /*
  Change the color of all alive cell
   */
   public void setColor (Color col) {
    for (Cell c : this.allCell) {
      c.col = col;
    }
  }

  /*
  Update all the cell alive and dead based on the two rule
   
   Rule 1 : a living cell surounded by exactly 2 or 3 cell alive stay alive otherwise it dies
   
   Rule 2 : a dead cell become alive if she is surrounded by exactly 3 living cell
   */
   public void nextStep() {
    Cell[] newCellAlive = new Cell[0]; //The new tab containing all cell alive

    Cell []neighbors = new Cell[8]; // Contain the neighbors of a cell

    for (Cell c : cellAlive) { // We check all the living cell
      neighbors = this.getNeighbors(c);
      int nbNeighborsAlive = nbAlive(neighbors);

      if (nbNeighborsAlive == 2 || nbNeighborsAlive == 3) { // If the cell stay alive
        if (!contain(newCellAlive, c)) {
          newCellAlive = (Cell[])append(newCellAlive, c); // We add it to the new cellAlive tab otherwise we don't add it
        }
      }

      for (Cell cell : neighbors) { // We check each dead neighbors (to see if one become alive)
        if (cell != null && !cell.alive) { // If the neighbors is dead
          if (nbAlive(this.getNeighbors(cell)) == 3) { // And has exactly 3 alive neighbors
            if (!contain(newCellAlive, cell)) {
              newCellAlive = (Cell[])append(newCellAlive, cell); // We add the cell to the new cell Alive
            }
          }
        }
      }
    }

    for (Cell c : cellAlive) { // All previous cellAlive are set dead
      allCell[c.index].alive = false;
    }

    this.cellAlive = newCellAlive; // We change the cell Alive

    for (Cell c : cellAlive) { // All cell Alive become alive
      allCell[c.index].alive = true;
    }
  }

  //Set the speed
   public void setSpeed(int value) {
    this.previousFrame = 0;
    this.speed = 59 / value;
  }

  /*
  Return true if the tab in parameters contain the cell c
   */
   public boolean contain(Cell [] cells, Cell c) {
    for (Cell cell : cells) {
      if (c == cell) {
        return true;
      }
    }
    return false; // if no case matched
  }

  /*
  return the number of cell alive in the tab in parameter
   */
   public int nbAlive(Cell[] cell) {
    int nb = 0;
    for (Cell c : cell) {
      if (c != null && c.alive) { // If the cell is not null and alive we add 1 cell
        nb++;
      }
    }
    return nb;
  }

  //Return a tab containing all the neighbors of the cell in parameter
   public Cell[] getNeighbors (Cell c) {

    boolean onTopLine = c.index < nbCellLargeur; // True if the cell is on the line at the top of the grid
    boolean onLeftLine = c.index % nbCellLargeur == 0; // True if the cell is on the line at the left of the grid
    boolean onRightLine = c.index % nbCellLargeur == nbCellLargeur - 1; // True if the cell is on the line at the right of the grid
    boolean onBottomLine = c.index >= (nbCellHauteur-1) * nbCellLargeur; // True if the cell is on the line at the bottom of the grid

    if (!onTopLine && !onLeftLine && !onRightLine && !onBottomLine) { // the cell is n the middle
      return new Cell[]{allCell[c.index-nbCellLargeur-1], allCell[c.index-nbCellLargeur], allCell[c.index-nbCellLargeur+1], allCell[c.index+1], allCell[c.index+nbCellLargeur+1], allCell[c.index+nbCellLargeur], allCell[c.index+nbCellLargeur-1], allCell[c.index-1]}; //We return all cell around
    }

    if (onTopLine && !onLeftLine && !onRightLine) { // if the cell is not in a corner and on the top line
      return new Cell[]{null, null, null, allCell[c.index+1], allCell[c.index+nbCellLargeur+1], allCell[c.index+nbCellLargeur], allCell[c.index+nbCellLargeur-1], allCell[c.index-1]}; //We return everything except the 3 top neighbors
    }

    if (onBottomLine && !onLeftLine && !onRightLine) { // if the cell is not in a corner and on the bottom line
      return new Cell[]{allCell[c.index-nbCellLargeur-1], allCell[c.index-nbCellLargeur], allCell[c.index-nbCellLargeur+1], allCell[c.index+1], null, null, null, allCell[c.index-1]}; //We return everything except the 3 bottom neighbors
    }

    if (onLeftLine && !onTopLine && !onBottomLine) { // if the cell is not in a corner and on the left line
      return new Cell[]{null, allCell[c.index-nbCellLargeur], allCell[c.index-nbCellLargeur+1], allCell[c.index+1], allCell[c.index+nbCellLargeur+1], allCell[c.index+nbCellLargeur], null, null}; //We return everything except the 3 left neighbors
    }

    if (onRightLine && !onTopLine && !onBottomLine) { // if the cell is not in a corner and on the right line
      return new Cell[]{allCell[c.index-nbCellLargeur-1], allCell[c.index-nbCellLargeur], null, null, null, allCell[c.index+nbCellLargeur], allCell[c.index+nbCellLargeur-1], allCell[c.index-1]}; //We return everything except the 3 right neighbors
    }

    if (onRightLine && onTopLine) { // Top right corner
      return new Cell[]{null, null, null, null, null, allCell[c.index+nbCellLargeur], allCell[c.index+nbCellLargeur-1], allCell[c.index-1]}; //We return the 3 bottom left neighbors
    }

    if (onLeftLine && onTopLine) { // Top left corner
      return new Cell[]{null, null, null, allCell[c.index+1], allCell[c.index+nbCellLargeur+1], allCell[c.index+nbCellLargeur], null, null}; //We return the 3 bottom right neighbors
    }

    if (onRightLine && onBottomLine) { // bottom right corner
      return new Cell[]{allCell[c.index-nbCellLargeur-1], allCell[c.index-nbCellLargeur], null, null, null, null, null, allCell[c.index-1]}; //We return the 3 top left neighbors
    }

    //bottom left corner
    return new Cell[]{null, allCell[c.index-nbCellLargeur], allCell[c.index-nbCellLargeur+1], allCell[c.index+1], null, null, null, null}; //We return the 3 top right neighbors
  }

   public void click() {
    //Calculation of the cell clicked on
    int caseX = (int)(((mouseX - offsetX) - ((mouseX - offsetX) % this.allCell[0].largeur)) / this.allCell[0].largeur);
    int caseY = (int)((((mouseY - offsetY) - ((mouseY - offsetY) % this.allCell[0].longeur))) / this.allCell[0].longeur);

    int index = this.nbCellLargeur * caseY + caseX;
    if (index < allCell.length) {
      if (allCell[index].alive) { // If the cell clicked on is alive
        //She become dead
        allCell[index].alive = false;

        //We remove the cell from the tab of the cell alive
        Cell[] temp = new Cell[cellAlive.length - 1];
        int offset = 0;
        for (int i = 0; i < cellAlive.length; i++) {
          if (cellAlive[i] != allCell[index]) {
            temp[i+offset] = cellAlive[i];
          } else {
            offset = -1;
          }
        }
        this.cellAlive = temp;
      } else { // If the cell clicked on is dead

        //She become alive and we add it to the tab of alive cell
        allCell[index].alive = true;
        cellAlive = (Cell[]) append(cellAlive, allCell[index]);
      }
    }
  }

  /*
  Display the game
   */
   public void display() {
    stroke(0);
    strokeWeight(this.lineSize);
    fill(255);
    rect (offsetX, offsetY, this.nbCellLargeur * this.allCell[0].largeur, this.nbCellHauteur * this.allCell[0].longeur);
    //Display the lines
    for (int i = 1; i < this.nbCellLargeur; i++) {
      line(this.allCell[0].largeur * i + offsetX, 0, this.allCell[0].largeur * i + offsetX, height);
    }

    for (int i = 1; i < this.nbCellHauteur; i++) {
      line(0, this.allCell[0].longeur * i + offsetY, width, this.allCell[0].longeur * i + offsetY);
    }

    //display the cell alive
    for (Cell c : cellAlive) {
      c.display();
    }
  }
}

/*
This class represent a menu of an application
 */
class Menu {
  Button[] buttons; // Represent all the buttons of the menu
  Text[] texts; // Represent all the texts of the menu
  Cursor[] cursors; // Represent all the cursors of the menu

  Menu () {
    this.buttons = new Button[0];
    this.texts = new Text[0];
    this.cursors = new Cursor[0];
  }

  /*
  Add a button to the menu
   */
   public void addButton(Button b) {
    this.buttons = (Button[]) append(buttons, b);
  }

  /*
  Add a text to the menu
   */
   public void addText(Text t) {
    this.texts = (Text[]) append(texts, t);
  }

  /*
  Add a cursor to the menu
   */
   public void addCursor(Cursor c) {
    this.cursors = (Cursor[]) append(cursors, c);
  }
  /*
  Manage a click (by checking every button)
   */
   public void click () {
    for (Button b : this.buttons) {
      b.clicked();
    }
  }

  /*
  Manage a mouseDrag by checking every cursor
   */
   public void dragged() {
    for (Cursor c : this.cursors) { // foreach cursors

      if (c.selectorClicked()) { // if the currentCursor is clicked

        if (mouseX > c.posX - c.largeur / 2 && mouseX < c.posX + c.largeur / 2) { // If mouse is on the range of the bar

          float actualLargeur = (mouseX - (c.posX - c.largeur / 2));

          // Update value
          c.valuePourcent = ((actualLargeur * 100) / c.largeur ) / 100;
          c.updateValue();
        } else if (mouseX > c.posX - c.largeur / 2) { // if the mouse is on the right of the bar

          c.valuePourcent = 1;
        } else { // if the mouse is on the left of the bar

          c.valuePourcent = 0;
        }
      }
    }
  }

  /*
  Manage a mouse releasement (return the index of the button on wich the cursor was released or -1 if the mouse is not on a button)
   */
   public int release () {
    int index = 0;
    for (Button b : this.buttons) {
      if (b.released()) {
        return index;
      }
      index++;
    }
    return -1;
  }

  /*
  Display all the buttons of this menu
   */
   public void displayButtons() {
    for (Button b : this.buttons) {
      b.display();
    }
  }

  /*
  Display all the texts of this menu
   */
   public void displayTexts() {
    for (Text t : this.texts) {
      t.display();
    }
  }

  /*
  Display all the cursors of this menu
   */
   public void displayCursors() {
    for (Cursor c : this.cursors) {
      c.display();
    }
  }

  /*
  Display the whole menu
   */
   public void display() {
    displayButtons();
    displayTexts();
    displayCursors();
  }
}


  public void settings() { size(900, 900); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "main" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
